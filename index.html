<!DOCTYPE html>
<html lang="en">
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta charset="UTF-8">
	<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/bubble_chart.css">
    <title>Paye ta Planche</title>
    
</head>


<body>

<div class="container" style="text-align: center">
    <h1>Paye ta Planche</h1>
<div class="row">
    <div class="form-group col-xs-6">
        <form>
            <select onchange="regen();" class="form-control" id="dataset">
                <option value="data/data_task_10.csv" selected="selected">10 Taches</option>
                <option value="data/data_task_100.csv">100 Taches</option>
                <option value="data/data_task_1000.csv">1 000 Taches</option>
                <option value="data/data_task_10000.csv">10 000 Taches</option>
            </select>
            <label>Séléction du jeu de données</label>

        </form>
    </div>
    

	<div class="form-group col-xs-6">
		<form>
			<select onchange="regen();" class="form-control" id="user">
				<option value="All" selected="selected">Tous</option>
				<option value="Mike">Mike</option>
				<option value="Natasha">Natasha</option>
				<option value="Joe">Joe</option>
			</select>
			<label>Séléction de l'utilisateur</label>
		</form>
	</div>
	</div>
	<div class="container">
        <h2>Bar charts</h2>
	
        <div class="row">
            <div class="col-xs-6">
                <p>Nombre de tâches par statut</p>
                <svg width="300" height="300" id="barchart1"></svg>
            </div>

            <div class="col-xs-6">
                <p>Nombre de tâches par Priorité</p>
                <svg width="300" height="300" id="barchart2"></svg>
            </div>
        </div>


        <div class="row">
            <div class="col-12">
                <h2>Treemap</h2>
                <style>
                    form {
                        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
                    }

                    svg {
                        font: 10px sans-serif;
                    }

                    .legend {
                        font-size: 12px;
                    }

                    rect {
                        stroke-width: 2;
                    }
                </style>
                <svg id="treemap" width="960" height="400"></svg>


            </div>
        </div>
		
		<div class="row">
            <div class="col-12">
                <h2>Bubble</h2>
				    <div id="toolbar">
						<a id="all" class="button active">All Grants</a>
						<a id="status" class="button">Grants By Year</a>
					</div>
                <div id="vis"></div>


            </div>
        </div>
		
	</div>
</div>

<script src="https://code.jquery.com/jquery-3.2.1.js" integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE=" crossorigin="anonymous"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
</body>


<script>
    function draw_barchart(data, element, chart) {
        // Chart initialization
        //var user = $('#user').val();
        $(element).html("");
        var svg = d3.select(element),
            margin = {top: 20, right: 20, bottom: 30, left: 40},
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom,
            g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        // X axis
        var x = d3.scaleBand()
            .rangeRound([0, width])
            .paddingInner(0.1);
        // y axis
        var y = d3.scaleLinear()
            .rangeRound([height, 0]);
        //load data
        if (!chart) {
            // Group by status
            var nested_data = d3.nest()
                .key(function (d) {
                    return d.status;
                })
                .entries(data);
        } else {
            // Group by priority
            var nested_data = d3.nest()
                .key(function (d) {
                    return d.priority;
                })
                .entries(data);
        }
        //console.log(nested_data);
        // Color scale
        var z = d3.scaleOrdinal(d3.schemeCategory10);
        // Set domains of axes scales
        x.domain(nested_data.map(function (d) {
            return d.key;
        }));
        y.domain([0, d3.max(nested_data, function (d) {
            return d.values.length;
        })]);
        z.domain(nested_data.map(function (d) {
            return d.key;
        }))
        // Draw rect
        g.selectAll("rect")
            .data(nested_data)
            .enter().append("rect")
            .attr("x", function (d) {
                return x(d.key);
            })
            .attr("y", function (d) {
                return y(d.values.length);
            })
            .attr("height", function (d) {
                return height - y(d.values.length);
            })
            .attr("width", x.bandwidth())
            //.attr("fill", "red")
            .attr("fill", function (d, i) {
                return z(d.key);
            })
        // Draw x axis
        g.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));
        // Draw y axis
        g.append("g")
            .attr("class", "axis")
            .call(d3.axisLeft(y).ticks(null, "s"))
    }

    function generate_tree(data, element) {
        // Initialize SV
        var user = $('#user').val();
        $("#treemap").html("");
        var svg = d3.select(element),
            margin = {top: 20, right: 20, bottom: 30, left: 40},
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom,
            g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        // Color scale for categories
        var color = d3.scaleOrdinal(d3.schemeCategory10);
        // Prepare aggregation
        var nest = d3.nest()
            .key(function (d) {
                return d.priority;
            }) // First we aggregate by prority
            .key(function (d) {
                return d.status;
            }) // Then by status
            .rollup(function (leaves) {
                return {
                    "total_cpt": leaves.length, // Compute the number of tasks in each groupe
                    // Compute the total time associated with the tasks in this group
                    "total_time": d3.sum(leaves, function (d) {
                        return parseFloat(d.time);
                    })
                }
            });
        // Prepare treemap
        var treemap = d3.treemap()
            .size([width, height])
            .padding(1)
            .round(true);
        var root = d3.hierarchy({
            values: nest.entries(data)
        }, function (d) {
            return d.values;
        })
        // This create a unique identifier of each leaf
            .eachBefore(function (d) {
                d.data.id = (d.parent ? d.parent.data.id + "." : "") + (d.data.key ? d.data.key : "");
            })
            // This is the value that will be used to draw the rectangles
            .sum(function (d) {
                if (d.value) {
                    return d.value.total_time;
                }
            })
            // This is to display first the bigger rectangles
            .sort(function (a, b) {
                return b.value.total_time - a.value.total_time;
            });
        //console.log(root)
        // Do generate the treemap
        treemap(root);
        // Prepare each rectangle
        var cell = g.selectAll("g")
        // We do not draw the priority rectangles, only the leaves of the tree
            .data(root.leaves())
            .enter().append("g")
            // Use x0 and y0 generated by the treemap function
            .attr("transform", function (d) {
                return "translate(" + d.x0 + "," + d.y0 + ")";
            });
        // Draw the rectangle
        cell.append("rect")
            .attr("id", function (d) {
                return d.data.id;
            })
            .attr("width", function (d) {
                return d.x1 - d.x0;
            })
            .attr("height", function (d) {
                return d.y1 - d.y0;
            })
            // Use the parent attribute to set the color
            .attr("fill", function (d) {
                return color(d.parent.data.key);
            });
        // Draw the text (use a clipping path to deal with long strings)
        cell.append("clipPath")
            .attr("id", function (d) {
                return "clip-" + d.data.id;
            })
            .append("use")
            .attr("xlink:href", function (d) {
                return "#" + d.data.id;
            });
        cell.append("text")
            .attr("clip-path", function (d) {
                return "url(#clip-" + d.data.id + ")";
            })
            .text(function (d) {
                return d.data.key;
            })
            .attr("x", 4)
            .attr("y", 10);
        // Append a title (shown on mouse hover)
        cell.append("title")
            .text(function (d) {
                return "Total time : " + d.data.value.total_time;
            });
        var heightL = 100;
        var svgLeg = d3.select("#legend").append("svg")
            .attr("width", width)
            .attr("height", heightL)
        // Draw the legend
        var legendRectSize = 18;
        var legendSpacing = 4;
        var legend = svg.selectAll('.legend')
            .data(color.domain())
            .enter()
            .append('g')
            .attr('class', 'legend')
            .attr('transform', function (d, i) {
                var offset = 20 * color.domain().length / 2;
                var horz = 30 + i * 100 + 10;
                var vert = height + legendRectSize + 10;
                //vert = 0;
                //horz = 0;
                return 'translate(' + horz + ',' + vert + ')';
            });
        // These are the rectangles
        legend.append('rect')
            .attr('width', legendRectSize)
            .attr('height', legendRectSize)
            .style('fill', color)
            .style('stroke', color);
        // These are the texts
        legend.append('text')
            .attr('x', legendRectSize + 5)
            .attr('y', 10)
            .text(function (d) {
                return d
            })
    }
	

	function generate_bubble(data,element){
	
	src="src/tooltip.js"
	
		/* bubbleChart creation function. Returns a function that will
	 * instantiate a new bubble chart given a DOM element to display
	 * it in and a dataset to visualize.
	 *
	 * Organization and style inspired by:
	 * https://bost.ocks.org/mike/chart/
	 *
	 */
	function bubbleChart() {
	  // Constants for sizing
	  var width = 940;
	  var height = 600;

	  // tooltip for mouseover functionality
	  var tooltip = floatingTooltip('gates_tooltip', 240);

	  // Locations to move bubbles towards, depending
	  // on which view mode is selected.
	  var center = { x: width / 2, y: height / 2 };

	  var yearCenters = {
		DONE: { x: width / 3, y: height / 2 },
		DOING: { x: width / 2, y: height / 2 },
		TODO: { x: 2 * width / 3, y: height / 2 }
	  };

	  // X locations of the year titles.
	  var yearsTitleX = {
		DONE: 160,
		DOING: width / 2,
		TODO: width - 160
	  };

	  // @v4 strength to apply to the position forces
	  var forceStrength = 0.03;

	  // These will be set in create_nodes and create_vis
	  var svg = null;
	  var bubbles = null;
	  var nodes = [];

	  // Charge function that is called for each node.
	  // As part of the ManyBody force.
	  // This is what creates the repulsion between nodes.
	  //
	  // Charge is proportional to the diameter of the
	  // circle (which is stored in the radius attribute
	  // of the circle's associated data.
	  //
	  // This is done to allow for accurate collision
	  // detection with nodes of different sizes.
	  //
	  // Charge is negative because we want nodes to repel.
	  // @v4 Before the charge was a stand-alone attribute
	  //  of the force layout. Now we can use it as a separate force!
	  function charge(d) {
		return -Math.pow(d.radius, 2.0) * forceStrength;
	  }

	  // Here we create a force layout and
	  // @v4 We create a force simulation now and
	  //  add forces to it.
	  var simulation = d3.forceSimulation()
		.velocityDecay(0.2)
		.force('x', d3.forceX().strength(forceStrength).x(center.x))
		.force('y', d3.forceY().strength(forceStrength).y(center.y))
		.force('charge', d3.forceManyBody().strength(charge))
		.on('tick', ticked);

	  // @v4 Force starts up automatically,
	  //  which we don't want as there aren't any nodes yet.
	  simulation.stop();

	  // Nice looking colors - no reason to buck the trend
	  // @v4 scales now have a flattened naming scheme
	  var fillColor = d3.scaleOrdinal()
		.domain(['low', 'medium', 'high'])
		.range(['#d84b2a', '#beccae', '#7aa25c']);


	  /*
	   * This data manipulation function takes the raw data from
	   * the CSV file and converts it into an array of node objects.
	   * Each node will store data and visualization values to visualize
	   * a bubble.
	   *
	   * rawData is expected to be an array of data objects, read in from
	   * one of d3's loading functions like d3.csv.
	   *
	   * This function returns the new node array, with a node in that
	   * array for each element in the rawData input.
	   */
	  function createNodes(rawData) {
		// Use the max total_amount in the data as the max in the scale's domain
		// note we have to ensure the total_amount is a number.
		var maxAmount = d3.max(rawData, function (d) { return +d.time; });

		// Sizes bubbles based on area.
		// @v4: new flattened scale names.
		var radiusScale = d3.scalePow()
		  .exponent(0.5)
		  .range([2, 85])
		  .domain([0, maxAmount]);

		// Use map() to convert raw data into node data.
		// Checkout http://learnjsdata.com/ for more on
		// working with data.
		var myNodes = rawData.map(function (d) {
		  return {
			id: d.id,
			radius: radiusScale(+d.time/3),
			value: +d.time,
			name: d.name,
			org: d.who,
			priority: d.priority,
			status: d.status,
			x: Math.random() * 900,
			y: Math.random() * 800
		  };
		});

		// sort them to prevent occlusion of smaller nodes.
		myNodes.sort(function (a, b) { return b.value - a.value; });

		return myNodes;
	  }

	  /*
	   * Main entry point to the bubble chart. This function is returned
	   * by the parent closure. It prepares the rawData for visualization
	   * and adds an svg element to the provided selector and starts the
	   * visualization creation process.
	   *
	   * selector is expected to be a DOM element or CSS selector that
	   * points to the parent element of the bubble chart. Inside this
	   * element, the code will add the SVG continer for the visualization.
	   *
	   * rawData is expected to be an array of data objects as provided by
	   * a d3 loading function like d3.csv.
	   */
	  var chart = function chart(selector, rawData) {
		// convert raw data into nodes data
		nodes = createNodes(rawData);

		// Create a SVG element inside the provided selector
		// with desired size.
		svg = d3.select(selector)
		  .append('svg')
		  .attr('width', width)
		  .attr('height', height);

		// Bind nodes data to what will become DOM elements to represent them.
		bubbles = svg.selectAll('.bubble')
		  .data(nodes, function (d) { return d.id; });

		// Create new circle elements each with class `bubble`.
		// There will be one circle.bubble for each object in the nodes array.
		// Initially, their radius (r attribute) will be 0.
		// @v4 Selections are immutable, so lets capture the
		//  enter selection to apply our transtition to below.
		var bubblesE = bubbles.enter().append('circle')
		  .classed('bubble', true)
		  .attr('r', 0)
		  .attr('fill', function (d) { return fillColor(d.priority); })
		  .attr('stroke', function (d) { return d3.rgb(fillColor(d.priority)).darker(); })
		  .attr('stroke-width', 2)
		  .on('mouseover', showDetail)
		  .on('mouseout', hideDetail);

		// @v4 Merge the original empty selection and the enter selection
		bubbles = bubbles.merge(bubblesE);

		// Fancy transition to make bubbles appear, ending with the
		// correct radius
		bubbles.transition()
		  .duration(2000)
		  .attr('r', function (d) { return d.radius; });

		// Set the simulation's nodes to our newly created nodes array.
		// @v4 Once we set the nodes, the simulation will start running automatically!
		simulation.nodes(nodes);

		// Set initial layout to single group.
		groupBubbles();
	  };

	  /*
	   * Callback function that is called after every tick of the
	   * force simulation.
	   * Here we do the acutal repositioning of the SVG circles
	   * based on the current x and y values of their bound node data.
	   * These x and y values are modified by the force simulation.
	   */
	  function ticked() {
		bubbles
		  .attr('cx', function (d) { return d.x; })
		  .attr('cy', function (d) { return d.y; });
	  }

	  /*
	   * Provides a x value for each node to be used with the split by year
	   * x force.
	   */
	  function nodeYearPos(d) {
		return yearCenters[d.status].x;
	  }


	  /*
	   * Sets visualization in "single group mode".
	   * The year labels are hidden and the force layout
	   * tick function is set to move all nodes to the
	   * center of the visualization.
	   */
	  function groupBubbles() {
		hideYearTitles();

		// @v4 Reset the 'x' force to draw the bubbles to the center.
		simulation.force('x', d3.forceX().strength(forceStrength).x(center.x));

		// @v4 We can reset the alpha value and restart the simulation
		simulation.alpha(1).restart();
	  }


	  /*
	   * Sets visualization in "split by year mode".
	   * The year labels are shown and the force layout
	   * tick function is set to move nodes to the
	   * yearCenter of their data's year.
	   */
	  function splitBubbles() {
		showYearTitles();

		// @v4 Reset the 'x' force to draw the bubbles to their year centers
		simulation.force('x', d3.forceX().strength(forceStrength).x(nodeYearPos));

		// @v4 We can reset the alpha value and restart the simulation
		simulation.alpha(1).restart();
	  }

	  /*
	   * Hides Year title displays.
	   */
	  function hideYearTitles() {
		svg.selectAll('.status').remove();
	  }

	  /*
	   * Shows Year title displays.
	   */
	  function showYearTitles() {
		// Another way to do this would be to create
		// the year texts once and then just hide them.
		var yearsData = d3.keys(yearsTitleX);
		var years = svg.selectAll('.status')
		  .data(yearsData);

		years.enter().append('text')
		  .attr('class', 'status')
		  .attr('x', function (d) { return yearsTitleX[d]; })
		  .attr('y', 40)
		  .attr('text-anchor', 'middle')
		  .text(function (d) { return d; });
	  }


	  /*
	   * Function called on mouseover to display the
	   * details of a bubble in the tooltip.
	   */
	  function showDetail(d) {
		// change outline to indicate hover state.
		d3.select(this).attr('stroke', 'black');

		var content = '<span class="name">Title: </span><span class="value">' +
					  d.name +
					  '</span><br/>' +
					  '<span class="name">Amount: </span><span class="value">$' +
					  addCommas(d.value) +
					  '</span><br/>' +
					  '<span class="name">Year: </span><span class="value">' +
					  d.status +
					  '</span>';

		tooltip.showTooltip(content, d3.event);
	  }

	  /*
	   * Hides tooltip
	   */
	  function hideDetail(d) {
		// reset outline
		d3.select(this)
		  .attr('stroke', d3.rgb(fillColor(d.priority)).darker());

		tooltip.hideTooltip();
	  }

	  /*
	   * Externally accessible function (this is attached to the
	   * returned chart function). Allows the visualization to toggle
	   * between "single group" and "split by year" modes.
	   *
	   * displayName is expected to be a string and either 'year' or 'all'.
	   */
	  chart.toggleDisplay = function (displayName) {
		if (displayName === 'status') {
		  splitBubbles();
		} else {
		  groupBubbles();
		}
	  };


	  // return the chart function from closure.
	  return chart;
	}

	/*
	 * Below is the initialization code as well as some helper functions
	 * to create a new bubble chart instance, load the data, and display it.
	 */

	var myBubbleChart = bubbleChart();

	/*
	 * Function called once data is loaded from CSV.
	 * Calls bubble chart function to display inside #vis div.
	 */
	function display(error, data) {
	  if (error) {
		console.log(error);
	  }

	  myBubbleChart(element, data);
	}

	/*
	 * Sets up the layout buttons to allow for toggling between view modes.
	 */
	function setupButtons() {
	  d3.select('#toolbar')
		.selectAll('.button')
		.on('click', function () {
		  // Remove active class from all buttons
		  d3.selectAll('.button').classed('active', false);
		  // Find the button just clicked
		  var button = d3.select(this);

		  // Set it as the active button
		  button.classed('active', true);

		  // Get the id of the button
		  var buttonId = button.attr('id');

		  // Toggle the bubble chart based on
		  // the currently clicked button.
		  myBubbleChart.toggleDisplay(buttonId);
		});
	}

	/*
	 * Helper function to convert a number into a string
	 * and add commas to it to improve presentation.
	 */
	function addCommas(nStr) {
	  nStr += '';
	  var x = nStr.split('.');
	  var x1 = x[0];
	  var x2 = x.length > 1 ? '.' + x[1] : '';
	  var rgx = /(\d+)(\d{3})/;
	  while (rgx.test(x1)) {
		x1 = x1.replace(rgx, '$1' + ',' + '$2');
	  }

	  return x1 + x2;
	}

	// Load the data.
	d3.csv($("#dataset").val(), display);

	// setup the buttons.
	setupButtons();

	
	}
	
    function regen() {
        d3.csv($("#dataset").val(), function (d) {
            d.time = +d.time;
            var user = $("#user").val();
            if (d.who == user || user == 'All')
                return d;
        }, function (data) {
            generate_tree(data, '#treemap');
            draw_barchart(data, "#barchart1", true);
            draw_barchart(data, "#barchart2", false);
			generate_bubble(data, '#vis');
        });
    }

    $(document).ready(function () {
        regen();
        $('select').material_select();
    });
</script>



</html>