<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Treemap</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/css/materialize.min.css">
    <style>

        .axis .domain {
            display: none;
        }

        form {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        }

        svg {
            font: 10px sans-serif;
        }

        .legend {
            font-size: 12px;
        }

        rect {
            stroke-width: 2;
        }
    </style>
</head>
<div id="option">
    <select id="user" onchange="refresh_charts();">
        <option value="All">All</option>
        <option value="Natasha">Natasha</option>
        <option value="Mike">Mike</option>
        <option value="Joe">Joe</option>
    </select>
</div>
</form>
<div id="option">
        <select class="dataset" id="dataset" onchange="refresh_charts();">
            <option value="data_task_10.csv">10</option>
            <option value="data_task_100.csv">100</option>
            <option value="data_task_1000.csv">1000</option>
            <option value="data_task_10000.csv">10000</option>
        </select>
</div>
</div>
<div class="row">
    <div class="col-6">
        <svg id="treemap" width="960" height="400"></svg>
    </div>
    <div class="col-6">
        <svg id="barchart1" width="960" height="400"></svg>
    </div>
</div>
<div class="rwo">
    <svg id="barchart2" width="960" height="400"></svg>
</div>
</div>
</body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://code.jquery.com/jquery-3.2.1.js"
        integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE="
        crossorigin="anonymous"></script>

<script>

    //on change update users.
    function refresh_charts() {
        $('#barchart1').html('');
        d3.csv($("#dataset").val(), function (row) {
            var selected_user = $("#data_user").val();
            if (row.who == selected_user || selected_user == "All") {
                return row;
            }
        }, function (data) {
            console.log(data);
            draw_bar_chart(data, '#barchart1');
            draw_bar_chart(data, '#barchart2');
        });
    }
    function updateData(value) {
        console.log(value);
// Filter data by user
        refresh_charts();
    }
    function draw_bar_chart(data, element) {
        // Initialize SVG
        $("#treemap").html("");
        var svg = d3.select(element),
                margin = {top: 20, right: 20, bottom: 30, left: 40},
                width = +svg.attr("width") - margin.left - margin.right,
                height = +svg.attr("height") - margin.top - margin.bottom,
                g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Color scale for categories
        var color = d3.scaleOrdinal(d3.schemeCategory10);

        // Prepare aggregation
        var nest = d3.nest()
                .key(function (d) {
                    return d.priority;
                }) // First we aggregate by prority
                .key(function (d) {
                    return d.status;
                }) // Then by status
                .rollup(function (leaves) {
                    return {
                        "total_cpt": leaves.length, // Compute the number of tasks in each groupe
                        // Compute the total time associated with the tasks in this group
                        "total_time": d3.sum(leaves, function (d) {
                            return parseFloat(d.time);
                        })
                    }
                });

        // Prepare treemap
        var treemap = d3.treemap()
                .size([width, height])
                .padding(1)
                .round(true);

        // Load data
        d3.csv(dataset, function (data_full) {
            // Convert our data structure into a tree structure

            // data is filterred

            var root = d3.hierarchy({
                        values: nest.entries(data)
                    }, function (d) {
                        return d.values;
                    })
                    // This create a unique identifier of each leaf
                    .eachBefore(function (d) {
                        d.data.id = (d.parent ? d.parent.data.id + "." : "") + (d.data.key ? d.data.key : "");
                    })
                    // This is the value that will be used to draw the rectangles
                    .sum(function (d) {
                        if (d.value) {
                            return d.value.total_cpt;
                        }
                    })
                    // This is to display first the bigger rectangles
                    .sort(function (a, b) {
                        return b.value.total_cpt - a.value.total_cpt;
                    });
            //console.log(root)

            // Do generate the treemap
            treemap(root);

            // Prepare each rectangle
            var cell = g.selectAll("g")
                    // We do not draw the priority rectangles, only the leaves of the tree
                    .data(root.leaves())
                    .enter().append("g")
                    // Use x0 and y0 generated by the treemap function
                    .attr("transform", function (d) {
                        return "translate(" + d.x0 + "," + d.y0 + ")";
                    });

            // Draw the rectangle
            cell.append("rect")
                    .attr("id", function (d) {
                        return d.data.id;
                    })
                    .attr("width", function (d) {
                        return d.x1 - d.x0;
                    })
                    .attr("height", function (d) {
                        return d.y1 - d.y0;
                    })
                    // Use the parent attribute to set the color
                    .attr("fill", function (d) {
                        return color(d.parent.data.key);
                    });

            // Draw the text (use a clipping path to deal with long strings)
            cell.append("clipPath")
                    .attr("id", function (d) {
                        return "clip-" + d.data.id;
                    })
                    .append("use")
                    .attr("xlink:href", function (d) {
                        return "#" + d.data.id;
                    });
            cell.append("text")
                    .attr("clip-path", function (d) {
                        return "url(#clip-" + d.data.id + ")";
                    })
                    .text(function (d) {
                        return d.data.key;
                    })
                    .attr("x", 4)
                    .attr("y", 10);

            // Append a title (shown on mouse hover)
            cell.append("title")
                    .text(function (d) {
                        return "Total task : " + d.data.value.total_cpt;
                    });
            var heightL = 100;
            var svgLeg = d3.select("#legend").append("svg")
                    .attr("width", width)
                    .attr("height", heightL)

            // Draw the legend
            var legendRectSize = 18;
            var legendSpacing = 4;
            var legend = svg.selectAll('.legend')
                    .data(color.domain())
                    .enter()
                    .append('g')
                    .attr('class', 'legend')
                    .attr('transform', function (d, i) {
                        var offset = 20 * color.domain().length / 2;
                        var horz = 30 + i * 100 + 10;
                        var vert = height + legendRectSize + 10;
                        //vert = 0;
                        //horz = 0;
                        return 'translate(' + horz + ',' + vert + ')';
                    });

            // These are the rectangles
            legend.append('rect')
                    .attr('width', legendRectSize)
                    .attr('height', legendRectSize)
                    .style('fill', color)
                    .style('stroke', color);

            // These are the texts
            legend.append('text')
                    .attr('x', legendRectSize + 5)
                    .attr('y', 10)
                    .text(function (d) {
                        return d
                    })
        });
        refresh_treemap();
        // Chart initialization
        function refresh_barchart(element) {
            var selected_user = $('#user').val();
            var dataset = $('#dataset').val();
            console.log(dataset);
            console.log(selected_user);
            var svg = d3.select(element),
                    margin = {top: 20, right: 20, bottom: 30, left: 40},
                    width = +svg.attr("width") - margin.left - margin.right,
                    height = +svg.attr("height") - margin.top - margin.bottom,
                    g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // X axis
            var x = d3.scaleBand()
                    .rangeRound([0, width])
                    .paddingInner(0.1);

            // y axis
            var y = d3.scaleLinear()
                    .rangeRound([height, 0]);

            //load data
            d3.csv(dataset, function (data_full) {
                //console.log(data);

                // data complet
                data = [];
                data_full.forEach(function (d) {
                    if (d.who == selected_user || selected_user == 'All') {
                        data.push(d);
                    }
                });
                // Group by status
                var nested_data = d3.nest()
                        .key(function (d) {
                            return d.status;
                        })
                        .entries(data);

                //console.log(nested_data);

                // Color scale
                var z = d3.scaleOrdinal(d3.schemeCategory10);

                // Set domains of axes scales
                x.domain(nested_data.map(function (d) {
                    return d.key;
                }));
                y.domain([0, d3.max(nested_data, function (d) {
                    return d.values.length;
                })]);
                z.domain(nested_data.map(function (d) {
                    return d.key;
                }))

                // Draw rect
                g.selectAll("rect")
                        .data(nested_data)
                        .enter().append("rect")
                        .attr("x", function (d) {
                            return x(d.key);
                        })
                        .attr("y", function (d) {
                            return y(d.values.length);
                        })
                        .attr("height", function (d) {
                            return height - y(d.values.length);
                        })
                        .attr("width", x.bandwidth())
                        //.attr("fill", "red")
                        .attr("fill", function (d, i) {
                            return z(d.key);
                        });

                // Draw x axis
                g.append("g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + height + ")")
                        .call(d3.axisBottom(x));

                // Draw y axis
                g.append("g")
                        .attr("class", "axis")
                        .call(d3.axisLeft(y).ticks(null, "s"))
            });
            ;
            refresh_barchart("#barchart1");
            // Chart initialization
            function refresh_barchart(element) {
                var selected_user = $('#user').val();
                var dataset = $('#dataset').val();
                console.log(dataset);
                console.log(selected_user);
                var svg = d3.select(element),
                        margin = {top: 20, right: 20, bottom: 30, left: 40},
                        width = +svg.attr("width") - margin.left - margin.right,
                        height = +svg.attr("height") - margin.top - margin.bottom,
                        g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                // X axis
                var x = d3.scaleBand()
                        .rangeRound([0, width])
                        .paddingInner(0.1);

                // y axis
                var y = d3.scaleLinear()
                        .rangeRound([height, 0]);

                //load data
                d3.csv(dataset, function (data_full) {
                    //console.log(data);

                    // Group by status
                    var nested_data = d3.nest()
                            .key(function (d) {
                                return d.status;
                            })
                            .entries(data);

                    //console.log(nested_data);

                    // Color scale
                    var z = d3.scaleOrdinal(d3.schemeCategory10);

                    // Set domains of axes scales
                    x.domain(nested_data.map(function (d) {
                        return d.key;
                    }));
                    y.domain([0, d3.max(nested_data, function (d) {
                        return d.values.length;
                    })]);
                    z.domain(nested_data.map(function (d) {
                        return d.key;
                    }))

                    // Draw rect
                    g.selectAll("rect")
                            .data(nested_data)
                            .enter().append("rect")
                            .attr("x", function (d) {
                                return x(d.key);
                            })
                            .attr("y", function (d) {
                                return y(d.values.length);
                            })
                            .attr("height", function (d) {
                                return height - y(d.values.length);
                            })
                            .attr("width", x.bandwidth())
                            //.attr("fill", "red")
                            .attr("fill", function (d, i) {
                                return z(d.key);
                            });

                    // Draw x axis
                    g.append("g")
                            .attr("class", "axis")
                            .attr("transform", "translate(0," + height + ")")
                            .call(d3.axisBottom(x));

                    // Draw y axis
                    g.append("g")
                            .attr("class", "axis")
                            .call(d3.axisLeft(y).ticks(null, "s"))
                });
            }
            ;
            refresh_barchart("#barchart2")
        }
</script>

</html>